// Code generated by gola {{.VERSION}}; DO NOT EDIT.

package {{.Package}}
{{$table := .}}
import (
	"database/sql"
	"reflect"
	"strings"

	"github.com/olachat/gola/coredb"

	{{.Imports}}
)

var _db *sql.DB

func Setup(db *sql.DB) {
	_db = db
}

// {{.ClassName}} represents {{.Name}} table
type {{.ClassName}} struct {
	{{- range .Columns }}
	// {{.Comment}} {{.DBType}}
	{{.GoName}}
	{{- end }}
}

type {{.ClassName}}Table struct{}

func (*{{.ClassName}}Table) GetTableName() string {
	return "{{.Name}}"
}

var table *{{.ClassName}}Table

{{- if .HasCompositePrimaryKey }}
type PK struct {
	{{- range .GetPKColumns }}
	{{.GoName}} {{.GoType}}
	{{- end }}
}
{{- end}}

type withPK interface {
	{{- range .GetPKColumns }}
	Get{{.GoName}}() {{.GoType}}
	{{- end }}
}

// Fetch{{.ClassName}}ByPKs returns a row from {{.Name}} table with given primary key value
func Fetch{{.ClassName}}ByPK(val {{.GetPrimaryKeyType}}) *{{.ClassName}} {
	return coredb.FetchByPK[{{.ClassName}}](_db, []string{ {{.GetPrimaryKeyNames}} }, {{.GetPrimaryKeyVals}})
}
// FetchByPKs returns a row with selected fields from {{.Name}} table with given primary key value
func FetchByPK[T any](val {{.GetPrimaryKeyType}}) *T {
	return coredb.FetchByPK[T](_db, []string{ {{.GetPrimaryKeyNames}} }, {{.GetPrimaryKeyVals}})
}
{{- if not .HasCompositePrimaryKey }}
// Fetch{{.ClassName}}ByPKs returns rows with from {{.Name}} table with given primary key values
func Fetch{{.ClassName}}ByPKs(vals ...{{.GetPrimaryKeyType}}) []*{{.ClassName}} {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKs[{{.ClassName}}](pks, "{{.GetPrimaryKeyName}}", _db)
}

// FetchByPKs returns rows with selected fields from {{.Name}} table with given primary key values
func FetchByPKs[T any](vals ...{{.GetPrimaryKeyType}}) []*T {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKs[T](pks, "{{.GetPrimaryKeyName}}", _db)
}
{{- end}}

// FindOne{{.ClassName}} returns a row from {{.Name}} table with arbitary where query
// whereSQL must start with "where ..."
func FindOne{{.ClassName}}(whereSQL string, params ...any) *{{.ClassName}} {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[{{.ClassName}}](w, _db)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
func Count(whereSQL string, params ...any) (int, error) {
	return coredb.QueryInt("SELECT COUNT(*) FROM {{.Name}} " + whereSQL, _db, params...)
}

// FindOne returns a row with selected fields from {{.Name}} table with arbitary where query
// whereSQL must start with "where ..."
func FindOne[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[T](w, _db)
}

// Find{{.ClassName}} returns rows from {{.Name}} table with arbitary where query
// whereSQL must start with "where ..."
func Find{{.ClassName}}(whereSQL string, params ...any) ([]*{{.ClassName}}, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[{{.ClassName}}](w, _db)
}

// Find returns rows with selected fields from {{.Name}} table with arbitary where query
// whereSQL must start with "where ..."
func Find[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[T](w, _db)
}

// Column types

{{- range .Columns }}
	{{- if .IsEnum}}
type {{$table.ClassName}}{{.GoName}} string
const (
	{{.GetEnumConst}}
)
	{{- end }}
	{{- if .IsSet}}
type {{$table.ClassName}}{{.GoName}} string
const (
	{{.GetSetConst}}
)
	{{- end }}
{{- end }}

{{- range .Columns }}

// {{.GoName}} field
// {{.Comment}}
{{- if .IsSet}}
type {{.GoName}} struct {
	_updated bool
	val string
}

func (c *{{.GoName}}) Get{{.GoName}}() []{{.GoType}} {
	strSlice := strings.Split(c.val, ",")
	valSlice := make([]{{.GoType}}, 0, len(strSlice))
	for _, s := range strSlice {
		valSlice = append(valSlice, {{.GoType}}(strings.ToLower(s)))
	}
	return valSlice
}

func (c *{{.GoName}}) Set{{.GoName}}(val []{{.GoType}}) bool {
	strSlice := make([]string, 0, len(val))
	for _, v := range val {
		strSlice = append(strSlice, string(v))
	}
	c.val = strings.Join(strSlice, ",")
	return true
}
{{else}}
type {{.GoName}} struct {
{{- if not .IsPrimaryKey}}
	_updated bool
{{- end}}
	val {{.GoType}}
}

func (c *{{.GoName}}) Get{{.GoName}}() {{.GoType}} {
	return c.val
}
{{ if not .IsPrimaryKey}}
func (c *{{.GoName}}) Set{{.GoName}}(val {{.GoType}}) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}
{{- end}}
{{end}}

{{- if not .IsPrimaryKey}}
func (c *{{.GoName}}) IsUpdated() bool {
	return c._updated
}

func (c *{{.GoName}}) resetUpdated()  {
	c._updated = false
}
{{- end}}

func (c *{{.GoName}}) GetColumnName() string {
	return "{{.Name}}"
}

func (c *{{.GoName}}) IsPrimaryKey() bool {
	return {{.IsPrimaryKey}}
}

func (c *{{.GoName}}) GetValPointer() any {
	return &c.val
}

func (c *{{.GoName}}) GetTableType() coredb.TableType {
	return table
}
{{- end }}

{{ if .IsPKAutoGenerated }}
func New{{.ClassName}}() *{{.ClassName}} {
	return &{{.ClassName}}{
	{{- range .Columns }}
	{{- if .HasDefault}}
	{{.GoName}}{val:{{.GoDefaultValue}}},
	{{- else}}
	{{.GoName}}{},
	{{- end }}
	{{- end }}
	}
}
{{- end }}

func New{{.ClassName}}WithPK(val {{.GetPrimaryKeyType}}) *{{.ClassName}} {
	c := &{{.ClassName}}{
	{{- range .Columns }}
	{{- if .HasDefault}}
	{{.GoName}}{val:{{.GoDefaultValue}}},
	{{- else}}
	{{.GoName}}{},
	{{- end }}
	{{- end }}
	}

	{{- if .HasCompositePrimaryKey }}
	{{- range $i, $c := .GetPKColumns }}
	c.{{ $c.GoName }}.val = val.{{ $c.GoName }}
	{{- end }}
	{{- else }}
	c.{{.GetPrimaryKey}}.val = val
	{{- end}}
	return c
}

func (c *{{.ClassName}}) Insert() error {
	sql := `INSERT IGNORE INTO {{.Name}} (
		{{- range $i, $c := .GetNonAutoIncrementColumns }}
		{{- if $i}}, {{end}}
		{{- $c.Name}}
		{{- end }}) values (
		{{- range $i, $c := .GetNonAutoIncrementColumns }}
		{{- if $i}}, {{end}}?
		{{- end }})`

	result, err := coredb.Exec(sql, _db, {{- range $i, $c := .GetNonAutoIncrementColumns }}
	{{- if $i}}, {{end}}c.Get{{$c.GoName}}()
	{{- end }})

	if err != nil {
		return err
	}

	{{- if .IsPKAutoGenerated}}
	id, err := result.LastInsertId()
	if err != nil {
		return err
	}

	c.{{.GetPrimaryKey}}.val = {{.GetPrimaryKeyType}}(id)
	{{- end }}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if affectedRows == 0 {
		return coredb.ErrAvoidInsert
	}

	c.resetUpdated()
	return nil
}

func (c *{{.ClassName}}) resetUpdated() {
	{{- range .GetNonPKColumns }}
	c.{{.GoName}}.resetUpdated()
	{{- end }}
}

func (obj *{{.ClassName}}) Update() (bool, error) {
	var updatedFields []string
	var params []any

	{{- range $i, $c := .GetNonPKColumns }}
	if obj.{{ $c.GoName }}.IsUpdated() {
		updatedFields = append(updatedFields, "{{ $c.Name }} = ?")
		params = append(params, obj.Get{{ $c.GoName }}())
	}
	{{- end }}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE {{.Name}} SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE {{.GetPrimaryKeySQL}}"
	params = append(params, {{.GetPrimaryKeyParams}})

	result, err := coredb.Exec(sql, _db, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	obj.resetUpdated()
	return true, nil
}

func Update(obj withPK) (bool, error) {
	var updatedFields []string
	var params []any
	var resetFuncs []func()

	val := reflect.ValueOf(obj).Elem()
	updatedFields = make([]string, 0, val.NumField())
	params = make([]any, 0, val.NumField())

	for i := 0; i < val.NumField(); i++ {
		col := val.Field(i).Addr().Interface()

		switch c := col.(type) {
		{{- range $i, $c := .GetNonPKColumns }}
		case *{{.GoName}}:
		if c.IsUpdated() {
			updatedFields = append(updatedFields, "{{ $c.Name }} = ?")
			params = append(params, c.Get{{ $c.GoName }}())
			resetFuncs = append(resetFuncs, c.resetUpdated)
		}
		{{- end }}
		}
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE {{.Name}} SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE {{.GetPrimaryKeySQL}}"
	params = append(params, {{.GetPrimaryKeyParams}})

	result, err := coredb.Exec(sql, _db, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	for _, f := range resetFuncs {
		f()
	}
	return true, nil
}

func (obj *{{.ClassName}}) Delete() (error) {
	sql := `DELETE FROM {{.Name}} WHERE {{.GetPrimaryKeySQL}}`

	_, err := coredb.Exec(sql, _db, {{.GetPrimaryKeyParams}})
	return err
}

func Delete(obj withPK) (error) {
	sql := `DELETE FROM {{.Name}} WHERE {{.GetPrimaryKeySQL}}`

	_, err := coredb.Exec(sql, _db, {{.GetPrimaryKeyParams}})
	return err
}
